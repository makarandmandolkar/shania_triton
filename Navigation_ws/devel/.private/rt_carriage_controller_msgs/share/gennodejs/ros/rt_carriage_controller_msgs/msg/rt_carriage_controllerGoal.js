// Auto-generated. Do not edit!

// (in-package rt_carriage_controller_msgs.msg)


"use strict";

const _serializer = _ros_msg_utils.Serialize;
const _arraySerializer = _serializer.Array;
const _deserializer = _ros_msg_utils.Deserialize;
const _arrayDeserializer = _deserializer.Array;
const _finder = _ros_msg_utils.Find;
const _getByteLength = _ros_msg_utils.getByteLength;

//-----------------------------------------------------------

class rt_carriage_controllerGoal {
  constructor(initObj={}) {
    if (initObj === null) {
      // initObj === null is a special case for deserialization where we don't initialize fields
      this.move_type_enum = null;
      this.position_Goal = null;
      this.position_tolerance = null;
      this.mission_type_enum = null;
      this.sensor_type_enum = null;
      this.forktip_distance = null;
    }
    else {
      if (initObj.hasOwnProperty('move_type_enum')) {
        this.move_type_enum = initObj.move_type_enum
      }
      else {
        this.move_type_enum = 0;
      }
      if (initObj.hasOwnProperty('position_Goal')) {
        this.position_Goal = initObj.position_Goal
      }
      else {
        this.position_Goal = 0.0;
      }
      if (initObj.hasOwnProperty('position_tolerance')) {
        this.position_tolerance = initObj.position_tolerance
      }
      else {
        this.position_tolerance = 0.0;
      }
      if (initObj.hasOwnProperty('mission_type_enum')) {
        this.mission_type_enum = initObj.mission_type_enum
      }
      else {
        this.mission_type_enum = 0;
      }
      if (initObj.hasOwnProperty('sensor_type_enum')) {
        this.sensor_type_enum = initObj.sensor_type_enum
      }
      else {
        this.sensor_type_enum = 0;
      }
      if (initObj.hasOwnProperty('forktip_distance')) {
        this.forktip_distance = initObj.forktip_distance
      }
      else {
        this.forktip_distance = 0.0;
      }
    }
  }

  static serialize(obj, buffer, bufferOffset) {
    // Serializes a message object of type rt_carriage_controllerGoal
    // Serialize message field [move_type_enum]
    bufferOffset = _serializer.int32(obj.move_type_enum, buffer, bufferOffset);
    // Serialize message field [position_Goal]
    bufferOffset = _serializer.float64(obj.position_Goal, buffer, bufferOffset);
    // Serialize message field [position_tolerance]
    bufferOffset = _serializer.float32(obj.position_tolerance, buffer, bufferOffset);
    // Serialize message field [mission_type_enum]
    bufferOffset = _serializer.int32(obj.mission_type_enum, buffer, bufferOffset);
    // Serialize message field [sensor_type_enum]
    bufferOffset = _serializer.int32(obj.sensor_type_enum, buffer, bufferOffset);
    // Serialize message field [forktip_distance]
    bufferOffset = _serializer.float64(obj.forktip_distance, buffer, bufferOffset);
    return bufferOffset;
  }

  static deserialize(buffer, bufferOffset=[0]) {
    //deserializes a message object of type rt_carriage_controllerGoal
    let len;
    let data = new rt_carriage_controllerGoal(null);
    // Deserialize message field [move_type_enum]
    data.move_type_enum = _deserializer.int32(buffer, bufferOffset);
    // Deserialize message field [position_Goal]
    data.position_Goal = _deserializer.float64(buffer, bufferOffset);
    // Deserialize message field [position_tolerance]
    data.position_tolerance = _deserializer.float32(buffer, bufferOffset);
    // Deserialize message field [mission_type_enum]
    data.mission_type_enum = _deserializer.int32(buffer, bufferOffset);
    // Deserialize message field [sensor_type_enum]
    data.sensor_type_enum = _deserializer.int32(buffer, bufferOffset);
    // Deserialize message field [forktip_distance]
    data.forktip_distance = _deserializer.float64(buffer, bufferOffset);
    return data;
  }

  static getMessageSize(object) {
    return 32;
  }

  static datatype() {
    // Returns string type for a message object
    return 'rt_carriage_controller_msgs/rt_carriage_controllerGoal';
  }

  static md5sum() {
    //Returns md5sum for a message object
    return '7e6c7501f66c1b8ed00a522d5a5aab57';
  }

  static messageDefinition() {
    // Returns full string definition for message
    return `
    # ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======
    #goal
    int32 MOVE_UNDEFINED_REQUEST=0
    int32 MOVE_ABSOLUTE      =1
    int32 MOVE_RELATIVE      =2
    int32 CALIBRATE_REACH    =3
    int32 CALIBRATE_LIFT     =4
    int32 CALIBRATE_TILT     =5
    int32 CALIBRATE_SIDESHIFT =6
    
    int32 move_type_enum
    
    float64 position_Goal
    float32 position_tolerance
    int32 mission_type_enum
    int32 MISSION_PICK = 1
    int32 MISSION_PLACE = 2
    int32 SENSOR_NO_SENSE                              =7
    int32 SENSOR_REACH_PAYLOAD_SENSE_LINEAR_CHANGE     =8
    int32 SENSOR_REACH_PAYLOAD_SENSE_NO_CHANGE         =9
    int32 SENSOR_REACH_FORKTIP_SENSE_COLLISION_CHANGE  =10
    int32 SENSOR_REACH_UNTIL_FORKTIP_SENSE_SENSE_VALUE =11
    int32 SENSOR_LIFT_UNTIL_LASER_READING =12
    int32 sensor_type_enum
    
    float64 forktip_distance
    
    
    `;
  }

  static Resolve(msg) {
    // deep-construct a valid message object instance of whatever was passed in
    if (typeof msg !== 'object' || msg === null) {
      msg = {};
    }
    const resolved = new rt_carriage_controllerGoal(null);
    if (msg.move_type_enum !== undefined) {
      resolved.move_type_enum = msg.move_type_enum;
    }
    else {
      resolved.move_type_enum = 0
    }

    if (msg.position_Goal !== undefined) {
      resolved.position_Goal = msg.position_Goal;
    }
    else {
      resolved.position_Goal = 0.0
    }

    if (msg.position_tolerance !== undefined) {
      resolved.position_tolerance = msg.position_tolerance;
    }
    else {
      resolved.position_tolerance = 0.0
    }

    if (msg.mission_type_enum !== undefined) {
      resolved.mission_type_enum = msg.mission_type_enum;
    }
    else {
      resolved.mission_type_enum = 0
    }

    if (msg.sensor_type_enum !== undefined) {
      resolved.sensor_type_enum = msg.sensor_type_enum;
    }
    else {
      resolved.sensor_type_enum = 0
    }

    if (msg.forktip_distance !== undefined) {
      resolved.forktip_distance = msg.forktip_distance;
    }
    else {
      resolved.forktip_distance = 0.0
    }

    return resolved;
    }
};

// Constants for message
rt_carriage_controllerGoal.Constants = {
  MOVE_UNDEFINED_REQUEST: 0,
  MOVE_ABSOLUTE: 1,
  MOVE_RELATIVE: 2,
  CALIBRATE_REACH: 3,
  CALIBRATE_LIFT: 4,
  CALIBRATE_TILT: 5,
  CALIBRATE_SIDESHIFT: 6,
  MISSION_PICK: 1,
  MISSION_PLACE: 2,
  SENSOR_NO_SENSE: 7,
  SENSOR_REACH_PAYLOAD_SENSE_LINEAR_CHANGE: 8,
  SENSOR_REACH_PAYLOAD_SENSE_NO_CHANGE: 9,
  SENSOR_REACH_FORKTIP_SENSE_COLLISION_CHANGE: 10,
  SENSOR_REACH_UNTIL_FORKTIP_SENSE_SENSE_VALUE: 11,
  SENSOR_LIFT_UNTIL_LASER_READING: 12,
}

module.exports = rt_carriage_controllerGoal;
