// Generated by gencpp from file monitor_utils/watched_node_data.msg
// DO NOT EDIT!


#ifndef MONITOR_UTILS_MESSAGE_WATCHED_NODE_DATA_H
#define MONITOR_UTILS_MESSAGE_WATCHED_NODE_DATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace monitor_utils
{
template <class ContainerAllocator>
struct watched_node_data_
{
  typedef watched_node_data_<ContainerAllocator> Type;

  watched_node_data_()
    : sequence(0)
    , name()
    , watch_rate(0)
    , startup_duration(0)
    , PID(0)
    , instantiation_time(0.0)
    , watched_topics()
    , is_alive(false)
    , is_hung(false)
    , is_publishing(false)
    , reboot_on_hang(false)
    , reboot_on_death(false)
    , reboot_on_publish_timeout(false)
    , reboot_count(0)
    , launch_script()  {
    }
  watched_node_data_(const ContainerAllocator& _alloc)
    : sequence(0)
    , name(_alloc)
    , watch_rate(0)
    , startup_duration(0)
    , PID(0)
    , instantiation_time(0.0)
    , watched_topics(_alloc)
    , is_alive(false)
    , is_hung(false)
    , is_publishing(false)
    , reboot_on_hang(false)
    , reboot_on_death(false)
    , reboot_on_publish_timeout(false)
    , reboot_count(0)
    , launch_script(_alloc)  {
  (void)_alloc;
    }



   typedef int64_t _sequence_type;
  _sequence_type sequence;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _name_type;
  _name_type name;

   typedef int32_t _watch_rate_type;
  _watch_rate_type watch_rate;

   typedef int32_t _startup_duration_type;
  _startup_duration_type startup_duration;

   typedef int32_t _PID_type;
  _PID_type PID;

   typedef double _instantiation_time_type;
  _instantiation_time_type instantiation_time;

   typedef std::vector<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > , typename ContainerAllocator::template rebind<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::other >  _watched_topics_type;
  _watched_topics_type watched_topics;

   typedef uint8_t _is_alive_type;
  _is_alive_type is_alive;

   typedef uint8_t _is_hung_type;
  _is_hung_type is_hung;

   typedef uint8_t _is_publishing_type;
  _is_publishing_type is_publishing;

   typedef uint8_t _reboot_on_hang_type;
  _reboot_on_hang_type reboot_on_hang;

   typedef uint8_t _reboot_on_death_type;
  _reboot_on_death_type reboot_on_death;

   typedef uint8_t _reboot_on_publish_timeout_type;
  _reboot_on_publish_timeout_type reboot_on_publish_timeout;

   typedef int32_t _reboot_count_type;
  _reboot_count_type reboot_count;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _launch_script_type;
  _launch_script_type launch_script;





  typedef boost::shared_ptr< ::monitor_utils::watched_node_data_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::monitor_utils::watched_node_data_<ContainerAllocator> const> ConstPtr;

}; // struct watched_node_data_

typedef ::monitor_utils::watched_node_data_<std::allocator<void> > watched_node_data;

typedef boost::shared_ptr< ::monitor_utils::watched_node_data > watched_node_dataPtr;
typedef boost::shared_ptr< ::monitor_utils::watched_node_data const> watched_node_dataConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::monitor_utils::watched_node_data_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::monitor_utils::watched_node_data_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::monitor_utils::watched_node_data_<ContainerAllocator1> & lhs, const ::monitor_utils::watched_node_data_<ContainerAllocator2> & rhs)
{
  return lhs.sequence == rhs.sequence &&
    lhs.name == rhs.name &&
    lhs.watch_rate == rhs.watch_rate &&
    lhs.startup_duration == rhs.startup_duration &&
    lhs.PID == rhs.PID &&
    lhs.instantiation_time == rhs.instantiation_time &&
    lhs.watched_topics == rhs.watched_topics &&
    lhs.is_alive == rhs.is_alive &&
    lhs.is_hung == rhs.is_hung &&
    lhs.is_publishing == rhs.is_publishing &&
    lhs.reboot_on_hang == rhs.reboot_on_hang &&
    lhs.reboot_on_death == rhs.reboot_on_death &&
    lhs.reboot_on_publish_timeout == rhs.reboot_on_publish_timeout &&
    lhs.reboot_count == rhs.reboot_count &&
    lhs.launch_script == rhs.launch_script;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::monitor_utils::watched_node_data_<ContainerAllocator1> & lhs, const ::monitor_utils::watched_node_data_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace monitor_utils

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::monitor_utils::watched_node_data_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::monitor_utils::watched_node_data_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::monitor_utils::watched_node_data_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::monitor_utils::watched_node_data_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::monitor_utils::watched_node_data_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::monitor_utils::watched_node_data_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::monitor_utils::watched_node_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "81c3123a2ea294b2971a0476e03b9bf8";
  }

  static const char* value(const ::monitor_utils::watched_node_data_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x81c3123a2ea294b2ULL;
  static const uint64_t static_value2 = 0x971a0476e03b9bf8ULL;
};

template<class ContainerAllocator>
struct DataType< ::monitor_utils::watched_node_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "monitor_utils/watched_node_data";
  }

  static const char* value(const ::monitor_utils::watched_node_data_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::monitor_utils::watched_node_data_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int64 sequence\n"
"string name\n"
"int32 watch_rate\n"
"int32 startup_duration\n"
"int32 PID\n"
"float64 instantiation_time\n"
"string[] watched_topics\n"
"bool is_alive\n"
"bool is_hung\n"
"bool is_publishing\n"
"bool reboot_on_hang\n"
"bool reboot_on_death\n"
"bool reboot_on_publish_timeout\n"
"int32 reboot_count\n"
"string launch_script\n"
"\n"
;
  }

  static const char* value(const ::monitor_utils::watched_node_data_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::monitor_utils::watched_node_data_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.sequence);
      stream.next(m.name);
      stream.next(m.watch_rate);
      stream.next(m.startup_duration);
      stream.next(m.PID);
      stream.next(m.instantiation_time);
      stream.next(m.watched_topics);
      stream.next(m.is_alive);
      stream.next(m.is_hung);
      stream.next(m.is_publishing);
      stream.next(m.reboot_on_hang);
      stream.next(m.reboot_on_death);
      stream.next(m.reboot_on_publish_timeout);
      stream.next(m.reboot_count);
      stream.next(m.launch_script);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct watched_node_data_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::monitor_utils::watched_node_data_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::monitor_utils::watched_node_data_<ContainerAllocator>& v)
  {
    s << indent << "sequence: ";
    Printer<int64_t>::stream(s, indent + "  ", v.sequence);
    s << indent << "name: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.name);
    s << indent << "watch_rate: ";
    Printer<int32_t>::stream(s, indent + "  ", v.watch_rate);
    s << indent << "startup_duration: ";
    Printer<int32_t>::stream(s, indent + "  ", v.startup_duration);
    s << indent << "PID: ";
    Printer<int32_t>::stream(s, indent + "  ", v.PID);
    s << indent << "instantiation_time: ";
    Printer<double>::stream(s, indent + "  ", v.instantiation_time);
    s << indent << "watched_topics[]" << std::endl;
    for (size_t i = 0; i < v.watched_topics.size(); ++i)
    {
      s << indent << "  watched_topics[" << i << "]: ";
      Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.watched_topics[i]);
    }
    s << indent << "is_alive: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_alive);
    s << indent << "is_hung: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_hung);
    s << indent << "is_publishing: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_publishing);
    s << indent << "reboot_on_hang: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reboot_on_hang);
    s << indent << "reboot_on_death: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reboot_on_death);
    s << indent << "reboot_on_publish_timeout: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.reboot_on_publish_timeout);
    s << indent << "reboot_count: ";
    Printer<int32_t>::stream(s, indent + "  ", v.reboot_count);
    s << indent << "launch_script: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.launch_script);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MONITOR_UTILS_MESSAGE_WATCHED_NODE_DATA_H
