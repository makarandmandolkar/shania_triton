// Generated by gencpp from file rt_mission_msgs/mobile_robot_pick_and_placeResult.msg
// DO NOT EDIT!


#ifndef RT_MISSION_MSGS_MESSAGE_MOBILE_ROBOT_PICK_AND_PLACERESULT_H
#define RT_MISSION_MSGS_MESSAGE_MOBILE_ROBOT_PICK_AND_PLACERESULT_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace rt_mission_msgs
{
template <class ContainerAllocator>
struct mobile_robot_pick_and_placeResult_
{
  typedef mobile_robot_pick_and_placeResult_<ContainerAllocator> Type;

  mobile_robot_pick_and_placeResult_()
    : success_Result(false)
    , mission_complete_time(0.0)
    , mission_distance(0.0)
    , exceeded_distance(0.0)
    , error_enum(0)  {
    }
  mobile_robot_pick_and_placeResult_(const ContainerAllocator& _alloc)
    : success_Result(false)
    , mission_complete_time(0.0)
    , mission_distance(0.0)
    , exceeded_distance(0.0)
    , error_enum(0)  {
  (void)_alloc;
    }



   typedef uint8_t _success_Result_type;
  _success_Result_type success_Result;

   typedef float _mission_complete_time_type;
  _mission_complete_time_type mission_complete_time;

   typedef float _mission_distance_type;
  _mission_distance_type mission_distance;

   typedef float _exceeded_distance_type;
  _exceeded_distance_type exceeded_distance;

   typedef int32_t _error_enum_type;
  _error_enum_type error_enum;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(ERROR_GENERIC_ERROR)
  #undef ERROR_GENERIC_ERROR
#endif
#if defined(_WIN32) && defined(ERROR_PALLET_NOT_FOUND)
  #undef ERROR_PALLET_NOT_FOUND
#endif
#if defined(_WIN32) && defined(ERROR_PALLET_OUT_OF_POSITION)
  #undef ERROR_PALLET_OUT_OF_POSITION
#endif
#if defined(_WIN32) && defined(ERROR_PLACE_LOCATION_NOT_CLEAR)
  #undef ERROR_PLACE_LOCATION_NOT_CLEAR
#endif
#if defined(_WIN32) && defined(ERROR_UNDEFINED_SENSOR_TYPE)
  #undef ERROR_UNDEFINED_SENSOR_TYPE
#endif
#if defined(_WIN32) && defined(ERROR_CARRIAGE_MOTION_FAILED)
  #undef ERROR_CARRIAGE_MOTION_FAILED
#endif
#if defined(_WIN32) && defined(ERROR_NAVIGATION_ERROR)
  #undef ERROR_NAVIGATION_ERROR
#endif
#if defined(_WIN32) && defined(ERROR_SAFETY_COMMUNICATION_ERROR)
  #undef ERROR_SAFETY_COMMUNICATION_ERROR
#endif
#if defined(_WIN32) && defined(ERROR_DEADMAN_TIMED_OUT)
  #undef ERROR_DEADMAN_TIMED_OUT
#endif
#if defined(_WIN32) && defined(ERROR_OVERSIZED_PAYLOAD)
  #undef ERROR_OVERSIZED_PAYLOAD
#endif
#if defined(_WIN32) && defined(ERROR_LOAD_ALREADY_ON_PALLET_FOR_PICK)
  #undef ERROR_LOAD_ALREADY_ON_PALLET_FOR_PICK
#endif

  enum {
    ERROR_GENERIC_ERROR = 0,
    ERROR_PALLET_NOT_FOUND = 1,
    ERROR_PALLET_OUT_OF_POSITION = 2,
    ERROR_PLACE_LOCATION_NOT_CLEAR = 3,
    ERROR_UNDEFINED_SENSOR_TYPE = 4,
    ERROR_CARRIAGE_MOTION_FAILED = 5,
    ERROR_NAVIGATION_ERROR = 6,
    ERROR_SAFETY_COMMUNICATION_ERROR = 7,
    ERROR_DEADMAN_TIMED_OUT = 8,
    ERROR_OVERSIZED_PAYLOAD = 9,
    ERROR_LOAD_ALREADY_ON_PALLET_FOR_PICK = 10,
  };


  typedef boost::shared_ptr< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> const> ConstPtr;

}; // struct mobile_robot_pick_and_placeResult_

typedef ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<std::allocator<void> > mobile_robot_pick_and_placeResult;

typedef boost::shared_ptr< ::rt_mission_msgs::mobile_robot_pick_and_placeResult > mobile_robot_pick_and_placeResultPtr;
typedef boost::shared_ptr< ::rt_mission_msgs::mobile_robot_pick_and_placeResult const> mobile_robot_pick_and_placeResultConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator1> & lhs, const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator2> & rhs)
{
  return lhs.success_Result == rhs.success_Result &&
    lhs.mission_complete_time == rhs.mission_complete_time &&
    lhs.mission_distance == rhs.mission_distance &&
    lhs.exceeded_distance == rhs.exceeded_distance &&
    lhs.error_enum == rhs.error_enum;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator1> & lhs, const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace rt_mission_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ac52838d542856c95a94291f388cced0";
  }

  static const char* value(const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xac52838d542856c9ULL;
  static const uint64_t static_value2 = 0x5a94291f388cced0ULL;
};

template<class ContainerAllocator>
struct DataType< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
{
  static const char* value()
  {
    return "rt_mission_msgs/mobile_robot_pick_and_placeResult";
  }

  static const char* value(const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# ====== DO NOT MODIFY! AUTOGENERATED FROM AN ACTION DEFINITION ======\n"
"#result definition\n"
"bool success_Result\n"
"float32 mission_complete_time\n"
"float32 mission_distance\n"
"\n"
"int32 ERROR_GENERIC_ERROR=0\n"
"int32 ERROR_PALLET_NOT_FOUND=1\n"
"int32 ERROR_PALLET_OUT_OF_POSITION=2\n"
"int32 ERROR_PLACE_LOCATION_NOT_CLEAR=3\n"
"int32 ERROR_UNDEFINED_SENSOR_TYPE=4\n"
"int32 ERROR_CARRIAGE_MOTION_FAILED=5\n"
"int32 ERROR_NAVIGATION_ERROR=6\n"
"int32 ERROR_SAFETY_COMMUNICATION_ERROR=7\n"
"int32 ERROR_DEADMAN_TIMED_OUT=8\n"
"int32 ERROR_OVERSIZED_PAYLOAD=9\n"
"int32 ERROR_LOAD_ALREADY_ON_PALLET_FOR_PICK=10\n"
"\n"
"float32 exceeded_distance\n"
"int32 error_enum\n"
;
  }

  static const char* value(const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.success_Result);
      stream.next(m.mission_complete_time);
      stream.next(m.mission_distance);
      stream.next(m.exceeded_distance);
      stream.next(m.error_enum);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct mobile_robot_pick_and_placeResult_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::rt_mission_msgs::mobile_robot_pick_and_placeResult_<ContainerAllocator>& v)
  {
    s << indent << "success_Result: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.success_Result);
    s << indent << "mission_complete_time: ";
    Printer<float>::stream(s, indent + "  ", v.mission_complete_time);
    s << indent << "mission_distance: ";
    Printer<float>::stream(s, indent + "  ", v.mission_distance);
    s << indent << "exceeded_distance: ";
    Printer<float>::stream(s, indent + "  ", v.exceeded_distance);
    s << indent << "error_enum: ";
    Printer<int32_t>::stream(s, indent + "  ", v.error_enum);
  }
};

} // namespace message_operations
} // namespace ros

#endif // RT_MISSION_MSGS_MESSAGE_MOBILE_ROBOT_PICK_AND_PLACERESULT_H
